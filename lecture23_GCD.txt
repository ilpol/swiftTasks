1. Исследуйте код ниже и напишите, какие цифры должны вывестись в консоль, объясните своими словами, почему именно такая последовательность по шагам.

func testQueue(){
    print("1")
    DispatchQueue.main.async {
        print("2")
        DispatchQueue.global(qos: .background).sync {
            print("3")
            DispatchQueue.main.sync {
                print("4")
                DispatchQueue.global(qos: .background).async {
                    print("5")
                }  
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}


Результат
1
9
2
3
дедлок

Объяснение:
сначала 1, т.к. это первый принт
потом 9, т.к. после 1 очередь запускается асинхронно, поэтому переключение на нее произойдет после выполнения основной функции
потом 2, т.к. это первый принт в асинхронном блоке
потом 3, т.к. идет запуск синхронного блока и дальше исполнение не пойдет, пока не выполнится этот синхронный блок
Затем будет ошибка из-за дедлока, т.к. синхронно запускаем в main, а он еще не закончился и синхронно ждет global, поэтому они бесконечно будут ждать друг друга



2. Создайте свою серийную очередь и замените в примере ей DispatchQueue.main, создайте свою конкурентную очередь и заменить ей DispatchQueue.global(qos: .background). Какой будет результат? Всегда ли будет одинаковым И почему?

Серийная
func testQueue(){
    print("1")
    DispatchQueue.main.sync {
        print("2")
        DispatchQueue.global(qos: .background).sync {
            print("3")
            DispatchQueue.main.sync {
                print("4")
                DispatchQueue.global(qos: .background).async {
                    print("5")
                }  
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}


будет
1
дедлок

Объяснение:
из main в main серийно запускаем блок кода, который ждет окончания функции, а функция дальше не выполняется, пока не завершится серийный блок кода, поэтому дедлок


Конкурентная
func testQueue(){
print("1")
    DispatchQueue.main.async {
        print("2")
        DispatchQueue.global(qos: .background).async {
            print("3")
            DispatchQueue.main.sync {
                print("4")
                DispatchQueue.global(qos: .background).async {
                    print("5")
                }  
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}


1
9
2
8
3
4
6
7
5

Объяснение:
сначала 1, т.к. то первый принт
потом 9, т.к. после 1 очередь запускается асинхронно, поэтому переключение на нее произойдет после выполнения основной функции
потом 2, т.к. это первый принт в асинхронном блоке
потом 8, т.к. затем запускается асинхронный блок только после выполнения текущего
потом 3, т.к. это первый принт в асинхронном блоке
потом 4, т.к. дальше идет синхронный блок, и на него передается управление из объемлющего блока
потом 6, т.к. асинхронный блок начинает выполняться только после завершения объемлющего блока
потом будет 7 или 5, их вывод будет в неопределенном порядке. Если блок с принтом 5, не успеет выполниться до принта 7 в объемлющем блоке, то выведется сначала 7, потом 5, а если успеет, то наоборот, сначала 5 потом 7.



3. Какой по номеру надо поменять sync/sync чтобы не возникало дедлока в обоих случаях?

Любой и можно сразу оба

Если поменять первый (в коде ниже уже изменение)

func testQueue(){
print("1")
    DispatchQueue.main.async {
        print("2")
        DispatchQueue.global(qos: .background).async {
            print("3")
            DispatchQueue.main.sync {
                print("4")
                DispatchQueue.global(qos: .background).async {
                    print("5")
                }
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}


1
9
2
8
3
4
6
7
5

1, 9, 2 будет как в первом пункте
затем 8, т.к. асинхронный блок запускается после выполнения объемлющего
затем 3 - первый принт в асинхронном блоке
затем 4, т.к. блок запускается синхронно
затем 6, т.к. асинхронный блок запускается после выполнения объемлющего
затем 7 или 5 в зависимости от как как долго будет выполняться асинхронный блок с принтом 5


Если поменять второй:

func testQueue(){
    print("1")
    DispatchQueue.main.async {
        print("2")
        DispatchQueue.global(qos: .background).sync {
            print("3")
            DispatchQueue.main.async {
                print("4")
                DispatchQueue.global(qos: .background).async {
                    print("5")
                }  
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}


1
9
2
3
7
8
4
6
5

1, 9, 2 будет как в первом пункте
затем 3, т.к. блок запускается синхронно
затем 7, т.к. асинхронный блок запускается после выполнения объемлющего
затем 8, т.к. асинхронный запустится после завершения объемлющего блока
затем 4, т.к. первый принт в асинхронном блоке
затем 6, т.к. асинхронный запустится после завершения объемлющего блока
затем 5, т.к. сам асинхронный блок


Если поменять оба:

func testQueue(){
print("1")
    DispatchQueue.main.async {
        print("2")
        DispatchQueue.global(qos: .background).async {
            print("3")
            DispatchQueue.main.async {
                print("4")
                DispatchQueue.global(qos: .background).async {
                    print("5")
                }  
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}


1
9
2
8
3
7
4
6
5

1, 9, 2 будет как в первом пункте
затем 8, т.к. асинхронный блок запускается после завершения объемлющего
затем 3 - первый принт в асинхронном блоке
затем 7, т.к. асинхронный блок запускается после завершения объемлющего
затем 4 - первый принт в асинхронном блоке
затем 6, т.к. асинхронный блок запускается после завершения объемлющего
затем 5, т.к. асинхронный блок запускается после завершения объемлющего



4. Как можно сделать в примере, чтобы очередь превратилась из конкурентной в серийную, подправьте пример не исправляя создания самой очереди

заменить все DispatchQueue.main на DispatchQueue.global(qos: .background) и все async на sync, там все задачи будут выполняться синхронно в глобально очереди

func testQueue(){
    print("1")
    DispatchQueue.global(qos: .background).sync {
        print("2")
        DispatchQueue.global(qos: .background).sync {
            print("3")
            DispatchQueue.global(qos: .background).sync {
                print("4")
                DispatchQueue.global(qos: .background).sync {
                    print("5")
                }
                print("6")
            }
            print("7")
        }
        print("8")
    }
    print("9")
}

будет
1
2
3
4
5
6
7
8
9

1 - первый принт
2, 3, 4, 5, т.к. блоки выполняются синхронно до завершения объемлющих
6, 7, 8, 9, т.к. выполняются после синхронно подблока




